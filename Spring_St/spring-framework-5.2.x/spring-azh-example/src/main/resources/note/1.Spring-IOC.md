# Spring-IOC 流程图

Spring-IOC bean 的创建大致执行流程如下：

![](../photos/1.Spring-IOC.png)

上图可以拆分为3个板块：

1. Spring 是什么；
2. Spring IOC简介以；
3. Spring bean 的创建；

## Spring 是什么

Spring 是一款开源的轻量级的开发框架。该框架的核心是 IOC (控制反转) 和 AOP (切面)。

## IOC

IOC (控制反转)：即研发不用关心对象或者组件的创建，销毁时机。将这些全部交由 Spring IOC 容器管理。IOC 理论实现了对象/组件之间的解耦，降低了代码的
维护成本，只使用简单的依赖注入即可完成对象/组件的创建，不用再关心对象/组件 之间的依赖关系，生命周期，只需要专注业务开发。

## AOP

AOP (切面)：


## bean 对象的创建 (读取文件配置)

先看下以 XML 文件配置 bean 属性， Spirng 是如何创建对象的，销毁流程后续再讲。

1. 在文件中自定义 bean 信息；
2. 加载文件并解析：BeanDefinitionReader；
3. 创建 beanDefinition 对象；
4. BeanFactoryPostProcessor 处理器：更改 bean 属性：比如 singleton 改为 prototype
5. 实例化 bean 对象：给对象分配内存空间；
6. 填充 bean 属性；
7. 设置 Aware 属性：获取 Spring 的一些属性
8. BeanPostProcessor 处理器 前置方法：设置 bean 属性；
9. 执行 bean 的初始化方法；
10. BeanPostProcessor 处理器 后置方法：设置 bean 属性

注意：7,9 步骤需要具体方法看是否实现了 BeanPostProcessor 接口；

# BeanFactoryPostProcessor 测试

实现该接口的方法会在 bean 实例化之前执行。即在 IOC 容器实例化任何 bean 之前, 允许 BeanFactoryPostProcessor 读取配置元数据。比如修改 singleton
属性为 prototype。并且可以同时配置多个 BeanFactoryPostProcessor, 并通过设置 order 来控制各个 BeanFactoryPostProcessor 执行次序。

创建 bean 类：

```java
public class MyJavaBeanDto implements InitializingBean {
	/**
	 * 姓名
	 */
	private String name;

	/**
	 * 备注
	 */
	private String remark;

	public MyJavaBeanDto() {
	}

	public MyJavaBeanDto(String name, String remark) {
		this.name = name;
		this.remark = remark;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getRemark() {
		return remark;
	}

	public void setRemark(String remark) {
		this.remark = remark;
	}

	/**
	 * 实例化后，在bean的属性初始化后执行
	 * @throws Exception
	 */
	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("MyJavaBeanDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行");
		this.remark = "MyJavaBeanDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行";
	}

	/**
	 * bean 类的初始化方法
	 */
	public void MyJavaBeanDtoInitMethod (){
		System.out.println("MyJavaBeanDto.MyJavaBeanDtoInitMethod 执行指定的初始化方法");
	}
}
```

实现 BeanFactoryPostProcessor 接口：

```java
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor, InitializingBean {

	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		System.out.println("MyBeanFactoryPostProcessor.postProcessBeanFactory 调用 MyBeanFactoryPostProcessor 的 postProcessBeanFactory ");
		BeanDefinition bd = beanFactory.getBeanDefinition("myJavaBeanDto");
		System.out.println("MyBeanFactoryPostProcessor.postProcessBeanFactory 属性值==========" + bd.getPropertyValues());
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("MyBeanFactoryPostProcessor->" + Class.forName("com.azh.springpostprocessor.service.MyBeanFactoryPostProcessor").getClass());
	}
}
```

定义 bean 属性：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    <!--测试解析 XML 文件获取 bean-->
    <bean id="userService" class="com.azh.springxmlparsebean.service.impl.UserServiceImpl"></bean>
    <!--测试 BeanFactoryPostProcessor-->
    	<bean id="myJavaBeanFactoryPostProcessorDto" class="com.azh.springpostprocessor.dto.MyJavaBeanFactoryPostProcessorDto" init-method="MyJavaBeanFactoryPostProcessorDtoMethod">
    		<property name="name" value="测试 BeanFactoryPostProcessor"/>
    		<property name="remark" value="备注信息：运行BeanFactoryPostProcessor"/>
    	</bean>
    	<bean id="myBeanFactoryPostProcessor" class="com.azh.springpostprocessor.service.MyBeanFactoryPostProcessor"/>

    <!--测试 BeanPostProcessor-->
    <bean id="myJavaBeanPostProcessorDto" class="com.azh.springpostprocessor.dto.MyJavaBeanPostProcessorDto" init-method="MyJavaBeanPostProcessorDtoMethod">
        <property name="name" value="测试 BeanPostProcessor"/>
        <property name="remark" value="备注信息：运行 BeanPostProcessor"/>
    </bean>
    <bean id="myBeanPostProcessor" class="com.azh.springpostprocessor.service.MyBeanPostProcessor"/>

</beans>

```

创建测试类：

```java
public class SpringBeanFactoryPostProcessorTest {

	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-config.xml");
		MyJavaBeanDto myJavaBeanDto = (MyJavaBeanDto) context.getBean("myJavaBeanDto");
		System.out.println("==================输出结果========================");
		System.out.println("SpringBeanFactoryPostProcessorTest.main 名称" + myJavaBeanDto.getName());
		System.out.println("SpringBeanFactoryPostProcessorTest.main 备注" + myJavaBeanDto.getRemark());
	}
}
```

执行程序输出结果为: 

```text
MyBeanFactoryPostProcessor->class java.lang.Class
MyBeanFactoryPostProcessor.postProcessBeanFactory 调用 MyBeanFactoryPostProcessor 的 postProcessBeanFactory 
MyBeanFactoryPostProcessor.postProcessBeanFactory 属性值==========PropertyValues: length=2; bean property 'name'; bean property 'remark'
MyJavaBeanDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行
MyJavaBeanDto.MyJavaBeanDtoInitMethod 执行指定的初始化方法
==================输出结果========================
SpringBeanFactoryPostProcessorTest.main 名称测试 BeanFactoryPostProcessor
SpringBeanFactoryPostProcessorTest.main 备注MyJavaBeanDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行
```
# BeanPostProcessor 测试

BeanPostProcessor 有两个方法：

1. postProcessBeforeInitialization() 在初始化方法之前执行；
2. postProcessAfterInitialization() 在初始化方法之后执行；

源码中对该类的描述是：允许自定义修改新的 bean 实例对象；另一方面也说明了该类的使拥范围，需要在 bean 被实例化之后使用。

1,2 中描述的初始化方法是指在定义 bean 的时候，通过 init-method 设置的方法。

创建 bean 类：

```java
public class MyJavaBeanPostProcessorDto implements InitializingBean {
	/**
	 * 姓名
	 */
	private String name;

	/**
	 * 备注
	 */
	private String remark;

	public MyJavaBeanPostProcessorDto() {
	}

	public MyJavaBeanPostProcessorDto(String name, String remark) {
		this.name = name;
		this.remark = remark;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getRemark() {
		return remark;
	}

	public void setRemark(String remark) {
		this.remark = remark;
	}

    /**
     * 实例化后，在bean的属性初始化后执行
	 * @throws Exception
	 */
	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("2. MyJavaBeanPostProcessorDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行");
		this.remark = "MyJavaBeanPostProcessorDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行";
	}

	/**
	 * bean 类的初始化方法
	 */
	public void MyJavaBeanPostProcessorDtoMethod (){
		System.out.println("3. MyJavaBeanPostProcessorDto.MyJavaBeanPostProcessorDtoMethod 执行指定的初始化方法");
	}
}
```

创建服务类：

```java
public class MyBeanPostProcessor implements BeanPostProcessor {

	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof MyJavaBeanPostProcessorDto) {
			System.out.println("1. BeanPostProcessor，对象" + beanName + "调用初始化方法之前的数据： " + bean.toString());
		}
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof MyJavaBeanPostProcessorDto) {
			System.out.println("4. BeanPostProcessor，对象" + beanName + "调用初始化方法之后的数据：" + bean.toString());
		}
		return bean;
	}
}
```

定义 bean 属性：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
	<!--测试解析 XML 文件获取 bean-->
	<bean id="userService" class="com.azh.springxmlparsebean.service.impl.UserServiceImpl"></bean>
	<!--测试 BeanFactoryPostProcessor-->
<!--	<bean id="myJavaBeanFactoryPostProcessorDto" class="com.azh.springpostprocessor.dto.MyJavaBeanFactoryPostProcessorDto" init-method="MyJavaBeanFactoryPostProcessorDtoMethod">-->
<!--		<property name="name" value="测试 BeanFactoryPostProcessor"/>-->
<!--		<property name="remark" value="备注信息：运行BeanFactoryPostProcessor"/>-->
<!--	</bean>-->
<!--	<bean id="myBeanFactoryPostProcessor" class="com.azh.springpostprocessor.service.MyBeanFactoryPostProcessor"/>-->

	<!--测试 BeanPostProcessor-->
	<bean id="myJavaBeanPostProcessorDto" class="com.azh.springpostprocessor.dto.MyJavaBeanPostProcessorDto" init-method="MyJavaBeanPostProcessorDtoMethod">
		<property name="name" value="测试 BeanPostProcessor"/>
		<property name="remark" value="备注信息：运行 BeanPostProcessor"/>
	</bean>
	<bean id="myBeanPostProcessor" class="com.azh.springpostprocessor.service.MyBeanPostProcessor"/>
	
</beans>
```

创建测试类

```java
public class SpringBeanPostProcessorTest {

	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-config.xml");
		MyJavaBeanPostProcessorDto myJavaBeanPostProcessorDto = (MyJavaBeanPostProcessorDto) context.getBean("myJavaBeanPostProcessorDto");
		System.out.println("==================输出结果========================");
		System.out.println("SpringBeanPostProcessorTest.main 名称" + myJavaBeanPostProcessorDto.getName());
		System.out.println("SpringBeanPostProcessorTest.main 备注" + myJavaBeanPostProcessorDto.getRemark());
	}
}
```

输出结果：

```text
1. BeanPostProcessor，对象myJavaBeanPostProcessorDto调用初始化方法之前的数据： com.azh.springpostprocessor.dto.MyJavaBeanPostProcessorDto@431cd9b2
2. MyJavaBeanPostProcessorDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行
3. MyJavaBeanPostProcessorDto.MyJavaBeanPostProcessorDtoMethod 执行指定的初始化方法
4. BeanPostProcessor，对象myJavaBeanPostProcessorDto调用初始化方法之后的数据：com.azh.springpostprocessor.dto.MyJavaBeanPostProcessorDto@431cd9b2
==================输出结果========================
SpringBeanPostProcessorTest.main 名称测试 BeanPostProcessor
SpringBeanPostProcessorTest.main 备注MyJavaBeanPostProcessorDto.afterPropertiesSet 实例化后，在bean的属性初始化后执行
```

根据输出结果：按照我们预想的输出顺序执行了。

# Aware 接口的作用

bean 通过实现 Aware 的相关接口可以获取到 IOC 容器其他属性。

# BeanFactory 和 FactoryBean

BeanFactory 接口创建对象是由 Spring IOC 创建管理的，需要遵循 Spring 的 bean 的生命周期；

FactoryBean 不需要经过 Spring bean 的创建流程，通过 getObject() 这个方法创建对象；

## FactoryBean 获取对象

创建对象类：

```java
public class FactoryBeanDto {
	private String desc;
	private String remark;

	public FactoryBeanDto() {
	}

	public FactoryBeanDto(String desc, String remark) {
		this.desc = desc;
		this.remark = remark;
	}

	public String getDesc() {
		return desc;
	}

	public void setDesc(String desc) {
		this.desc = desc;
	}

	public String getRemark() {
		return remark;
	}

	public void setRemark(String remark) {
		this.remark = remark;
	}
}

public class SpringFactoryBeanDto implements FactoryBean<FactoryBeanDto> {
    @Override
    public FactoryBeanDto getObject() throws Exception {
        return new FactoryBeanDto();
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }
}
```
创建测试类：

```java
public class SpringFactoryBeanTest {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-config.xml");
		Object factoryBeanDto = context.getBean("springFactoryBeanDto");
		if (factoryBeanDto instanceof  FactoryBeanDto){
			System.out.println("使用 beanFactory 创建对象");
		}
	}
}
```

输出结果:

```text
使用 beanFactory 创建对象
```
证明获取到的对象是 FactoryBeanDto。